## Структура кода
### Точка с запятой
Можно не ставить, но лучше ставить.
Так ошибка:
```
alert("Сейчас будет ошибка")
[1, 2].forEach(alert)
```
А так нет:
```
alert("Теперь всё в порядке");
[1, 2].forEach(alert)
```
JavaScript не вставляет точку с запятой перед квадратными скобками [...]
### Комментарии
// - одна строка
/* ... */ - много строк
Вкладывать многострочные нельзя:
```
/*
  /* ERROR */
*/
```
## Use strict
Используется для режима совместимости (изменяя поведение некоторых встроенных функци). Ставится в начале сценария. Отменить его нельзя.
Можно ставить в начале тела функци. Тогда аботает толкьо внутри функции.
> Некоторые функции языка, такие как «классы» и «модули», автоматически включают строгий режим.
##  Переменные
Вот так:
```sh
let message;
```
И так:
```sh
let user = 'John', age = 25, message = 'Hello';
```
И так:
```sh
let user = 'John',
  age = 25,
  message = 'Hello';
```
## Имена переменных
Используем CamelCase:
```sh
myVeryLongName
```
> Имя переменной должно содержать только буквы, цифры или символы ```$``` и ```_```.
> Первый символ не должен быть цифрой.
> Регистр имеет значение.
> Нельзя использовать ``` let, class, return``` и ```function```
> Без ```use strict``` можно и не использовать ``` let```, но так лучше не делать
## Константы
Объявили при помощи ```const``` и если попробуем изменить, то получим ошибку.
> Ошибка будет если мы меняем только само значение. Изменив атрибут объекта (который хранится в константе) ошибку мы не получим.
## Имена констант
Если значение известно, до момента выполнения скрипта - используем CAPS:
```
const COLOR_RED = "#F00";
```
Если значение константы вычисляется, то нет:
```
const pageLoadTime = /* время, потраченное на загрузку веб-страницы */;
```
> var – это устаревший способ объявления. Его вообще не используем его
## Типы данных
> Встроенна функция ```typeof``` возвращает строку с описанием типа данных.
### Примитивные типы
> Примитивные типы сохраняются как значения, в отличие от объектов, хранящихся в качестве ссылки. Можно переназначить примитивный тип переменной, но это будет новое значение, старое не будет и не может быть изменено.
#### Число
```
let n = 123;
n = 12.345;
```
Есть еще бесконечность:
```
alert( 1 / 0 ); // Infinity
alert( Infinity ); // Infinity
alert( -Infinity ); // Infinity
```
Также есть ```NaN``` (результат неправильной или неопределённой математической операции):
```
alert( "строка" / 2 + 5 ); // NaN
```
> Если где-то в математическом выражении есть NaN, то результатом вычислений с его участием будет NaN.
В JavaScript тип ```number```  может содержать числа от 2^-53^ до 2^53^. Для еще больших чисел есть еще ```BigInt```:
```
const bigInt = 1234567890123456789012345678901234567890n;
```
#### Строка
```
let str = "Привет";
let str2 = 'Одинарные кавычки тоже подойдут';
let phrase = `Обратные кавычки позволяют встраивать переменные ${str}`;
```
#### Булево
Ну булево и булево. Вот так с ними можно:
```
let isGreater = 4 > 1;
alert( isGreater ); 
```
#### NULL
Ничего, пустота, отсутствие всякого значения
#### Undefined
Ничего назначено не было
> NULL - чтобы присвоить пустое значение, Undefined - для проверки присваивалось ли какое-либо значение 
#### Symbol
Используется для уникальных идентификаторов.
### Объекты
> Объекты хранятся по ссылке

Все, что не является примитивным типом, является объектом (в том числе и функции). Это особенный тип. 
## Преобразование типов
### Преобразования примитивных типов
|Значение|В строку|В число|В булево|
|-|-|-|-|
|""|""|0|false|
|"   "|""|0|true|
|"a"|"a"|NaN|true|
|123|"123"|123|true|
|1.23|"1.23"|1.23|true|
|true|"true"|1|true|
|false|"false"|0|false|
|Infinity|"Infinity"|Infinity|true|
|NaN|"NaN"|NaN|false|
|null|"null"|0|false|
|undefined|"undefined"|NaN|false|

### Преобразование объектов
Все объекты наследуют два метода преобразования: ```toString()``` и ```valueOf()```.
Метод ```toString()``` возвращает строковое представление объекта. Некоторые типы имеют более специализированные версии метода ```toString()```.
Задача метода ```valueOf()``` определена не так чётко: предполагается, что он должен преобразовать объект в представляющее его простое значение, если такое значение существует
В строку:
* Если объект имеет метод ```toString()```, интерпретатор вызывает его. Если он возвращает простое значение, интерпретатор преобразует значение в строку (если оно не является строкой) и возвращает результат преобразования.
* Если объект не имеет метода ```toString()``` или этот метод не возвращает простое значение, то интерпретатор проверяет наличие метода ```valueOf()```. Если этот метод определён, интерпретатор вызывает его. Если он возвращает простое значение, интерпретатор преобразует это значение в строку (если оно не является строкой) и возвращает результат преобразования.
* В противном случае интерпретатор делает вывод, что ни ```toString()``` ни ```valueOf()``` не позволяют получить простое значение и возбуждает ошибку ```TypeError```.

В число:
* Если объект имеет метод valueOf(), возвращающий простое значение, интерпретатор преобразует (при необходимости) это значение в число и возвращает результат.
* Если объект не имеет метода valueOf() или этот метод не возвращает простое значение, то интерпретатор проверяет наличие метода toString(). Если объект имеет метод toString(), возвращающий простое значение, интерпретатор выполняет преобразование и возвращает полученное значение.
* В противном случае интерпретатор делает вывод, что ни toString() ни valueOf() не позволяют получить простое значение и возбуждает ошибку TypeError.
> Методы toString() и valueOf() доступны для чтения и записи, поэтому их можно переопределить и явно указать, что будет возвращаться при преобразовании

## Операторы
```Унарный``` - оператор, который применяется к одному операнду.
```Бинарный``` - оператор, который применяется к двум  операндам.
Приоритеты операторов (список далеко не полный):
|Приоритет|Оператор|
|-|-|
|16|унарный плюс|
|16|унарный минус|
|14|умножение|
|14|деление|	
|13|бинарный плюс|
|13|бинарный минус|
|3|присваивание|


### Унарный +
Ничего не делает с числами. Но если операнд не число, унарный плюс преобразует его в число.
```
let apples = "2";
let oranges = "3";
alert( +apples + +oranges ); // 5
```
### Унарный -
То же самое, что и ```унарный плюс```, только меняет знак.
### Умножение
Ну умножение и умножение. Преобразует операнды в числа.
### Деление
Ну деление и деление. Преобразует операнды в числа.


### Бинарный +
Складывате числа, если ему подсунуть числа.
Сложит как строки, если один из операндов будет строкой.
> Операции выполняются слева направо. Если перед строкой идут два числа, то числа будут сложены перед преобразованием в строку:
```
alert(2 + 2 + '1' ); // будет "41", а не "221"
```
Если операнд не строка и не число - преобразует в строку.
### Присваивание
Оно выполняется справа-налево:
```
a = b = c = 2 + 2;
```
Сначала вычисляется самое правое выражение ```2 + 2```, и затем оно присваивается переменным слева: ```c```, ```b``` и ```a```

### Инкремент\декремент
Префиксная форма возвращает новое значение:
```
let counter = 1;
let a = ++counter; // 2
```
Постфиксная форма возвращает старое
```
let counter = 1;
let a = counter++; // 1
```
> Инкремент/декремент можно применить только к переменной. Попытка использовать его на значении, типа ```5++```, приведёт к ошибке.
### Оператор запятая
Выполняет каждый из его операндов (слева направо) и возвращает значение последнего операнда.
```
let x = 1;
x = (x++, x);
console.log(x); //2
```
Jператор ```,``` имеет очень низкий приоритет, ниже ```=```, поэтому 
```
let a = (1 + 2, 3 + 4); // 7
```
```
let a = 1 + 2, 3 + 4; // 3
```



