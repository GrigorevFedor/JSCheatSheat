## Object
Объект - коллекция пар ключ\значение.
```
let user = new Object(); // синтаксис "конструктор объекта"
let user = {};  // синтаксис "литерал объекта"
```
Вот так со свойствами:
```
let user = {    
  name: "John", 
  age: 30,        
};
```
Прямо после объявления можно добавлять свойства:
```
user.isAdmin = true;
```
Удалить свойство:
```
delete user.age;
```
Можно из нескольких слов ключ сделать:
```
let user = {
  "likes birds": true  //должно быть в кавычках
};
```
Обратиться к такому свойству можно только при помощи ```[] ```
```
user["likes birds"] = true;
```
Если значение свойства совпадает с именем ключа, то можно так:
```
{name,  age};
{name: name,  age: age}; // то же самое
```

> В качестве ключа можно использовать только ```строки``` или  ```Symbol```. Все остальное будет преобразовано к строке.

> При обращении даже к несуществующему свойству - вернется ```undefined```

Проверить на существование свойства:
```
alert( user.noSuchProperty === undefined ); // true означает "свойства нет"
```
Или при помощи ```in```:
```
"key" in object
```
## FOR IN
Пернбрать свойства объекта:
```
for (let key in user)
```
Порядок обхода:
* Целочисленные свойства (это те ключи, которые можно преобразовать в число и обратно без изменений) по возрастанию ;
* Остальные в порядке создания.

## Копирование объектов
> Переменная хранит не сам объект, а его «адрес в памяти», другими словами «ссылку» на него.

> Операторы равенства == и строгого равенства === для объектов работают одинаково.
Два объекта равны только в том случае, если это один и тот же объект.

> Для сравнений типа obj1 > obj2 или для сравнения с примитивом obj == 5 объекты преобразуются в примитивы.

Чтобы сделать реальную копию объекта надо использовать ```Object.assign(dest, [objeects])```
```
Object.assign(dest, [src1, src2, src3...])
```
Метод копирует в ```dest``` все свойства объектов массива. Одинаковые свойства перезаписываются.

> Если одно из значений является объектом - придется рекурсивно перебирать и его. ПРоще использовать ```JSON```.

## Работа с памятью
Все просто - удалется все что является недостижимым. 

## SYMBOL
```SYMBOL``` - уникальный идентификатор.
```
let id = Symbol("id");
```
Символы с одинаковым описанием - не равны
```
let id1 = Symbol("id");
let id2 = Symbol("id");
alert(id1 == id2); // false
```
> Символы нельзя НЕявно преобразовать в строку
```
symbol.description // id
```
> Они нужны для того, чтобы добавлять свойства к объектам задействованным в стороннем коде. Потому что - например, их игнорирует ```for in``` и ```Object.keys(user)```. Таким образом сторонний код не сможет их задеть.

Если мы хотим работать символом из разных частей приложения - есть глобальный реестр символов.
Для чтения (или, при отсутствии, создания) символа из реестра используется вызов ```Symbol.for(key)```

## Системные символы
Существует множество «системных» символов, использующихся внутри самого JavaScript, и мы можем использовать их, чтобы настраивать различные аспекты поведения объектов.
Эти символы перечислены в спецификации в таблице Well-known symbols:
```Symbol.hasInstance```
```Symbol.isConcatSpreadable```
```Symbol.iterator```
```Symbol.toPrimitive```
…и так далее.
В частности, Symbol.toPrimitive позволяет описать правила для объекта, согласно которым он будет преобразовываться к примитиву.

## THIS
Используем когда нужен доступ к информации, которая хранится в объекте, внутри самого объекта.
Мы даже можем вызвать функцию вовсе без использования объекта:
```
function sayHi() {
  alert(this); //undefined
}
sayHi();
```
> В строгом режиме ("use strict") в таком коде значением this будет являться undefined. Если мы попытаемся получить доступ к name, используя this.name – это вызовет ошибку.
В нестрогом режиме значением this в таком случае будет глобальный объект (window для браузера)
###  Тонкости this
Для работы вызовов типа user.hi(), JavaScript использует – ```.``` Без скобок такой вызов возвращает не саму функцию, а специальное значение «ссылочного типа», называемого ```Reference Type```.
Это комбинация из трёх значений (base, name, strict), где:
```base``` – это объект.
```name``` – это имя свойства объекта.
```strict``` – это режим исполнения. Является true, если действует строгий режим (```use strict```).
Когда скобки ```()``` применяются к значению ссылочного типа (происходит вызов), то они получают полную информацию об объекте и его методе, и могут поставить правильный ```this``` (user в данном случае, по base).
```Reference Type``` – исключительно внутренний, промежуточный, используемый, чтобы передать информацию от точки . до вызывающих скобок ()
> ```obj['method']``` - также вернет ```Reference Type```

> У стрелочных функций нет «this»

Если мы используем this внутри стрелочной функции, то его значение берётся из внешней «нормальной» функции.
## Преобразование объектов в примитивы
Существует всего 3 типа преобразований (хинтов):
* ```string``` (для alert и других операций, которым нужна строка)
* ```number``` (для математических операций)
* ```default``` (для некоторых операций)

Алгоритм преобразований к примитивам следующий:
* Сначала вызывается метод ```obj[Symbol.toPrimitive](hint)```, если он существует.
* Иначе, если хинт равен ```string```
* происходит попытка вызвать ```obj.toString()```, затем ```obj.valueOf()```, смотря что есть.
Иначе, если хинт равен ```number``` или ```default```
происходит попытка вызвать ```obj.valueOf()```, затем ```obj.toString()```, смотря что есть.
> В спецификации ECMA указано, какой хинт должен использовать каждый оператор
Пример:
```
    let a = {
        name: 'Jhon',
        [Symbol.toPrimitive](hint){
            return hint == 'string' ? this.name : '100'   
        }
    }
    console.log(a) //Jhon
    console.log(+a) // 100

```
## Функция-конструктор
Вызываем с помошью ```new``` и вернет объект.
Функции-конструкторы являются обычными функциями. Но:
* Имя функции-конструктора должно начинаться с большой буквы.
* Функция-конструктор должна вызываться при помощи оператора ```new```.

Например:
```
function User(name) {
  this.name = name;
  this.isAdmin = false;
}
let user = new User("Вася");
alert(user.name); // Вася
alert(user.isAdmin); // false
```
Когда функция вызывается как ```new User(...)```, происходит следующее:
* Создаётся новый пустой объект, и он присваивается ```this```.
* Выполняется код функции. Обычно он модифицирует ```this```, добавляет туда новые свойства.
* Возвращается значение ```this```.
 
В случае, если функция вызвана при помощи new, то в ```new.target``` будет сама функция, в противном случае undefined.

```
function User() {
  alert(new.target);
}
User(); // undefined
new User(); // function User { ... }
```
В общем случае  ```return```  не нужен. Но если всё же он есть, то:
* При вызове ```return``` с объектом, будет возвращён объект, а не ```this```.
* При вызове ```return``` с примитивным значением, примитивное значение будет отброшено.





