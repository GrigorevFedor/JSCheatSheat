## Object
Объект - коллекция пар ключ\значение.
```
let user = new Object(); // синтаксис "конструктор объекта"
let user = {};  // синтаксис "литерал объекта"
```
Вот так со свойствами:
```
let user = {    
  name: "John", 
  age: 30,        
};
```
Прямо после объявления можно добавлять свойства:
```
user.isAdmin = true;
```
Удалить свойство:
```
delete user.age;
```
Можно из нескольких слов ключ сделать:
```
let user = {
  "likes birds": true  //должно быть в кавычках
};
```
Обратиться к такому свойству можно только при помощи ```[] ```
```
user["likes birds"] = true;
```
Если значение свойства совпадает с именем ключа, то можно так:
```
{name,  age};
{name: name,  age: age}; // то же самое
```

> В качестве ключа можно использовать только ```строки``` или  ```Symbol```. Все остальное будет преобразовано к строке.

> При обращении даже к несуществующему свойству - вернется ```undefined```

Проверить на существование свойства:
```
alert( user.noSuchProperty === undefined ); // true означает "свойства нет"
```
Или при помощи ```in```:
```
"key" in object
```
## FOR IN
Пернбрать свойства объекта:
```
for (let key in user)
```
Порядок обхода:
* Целочисленные свойства (это те ключи, которые можно преобразовать в число и обратно без изменений) по возрастанию ;
* Остальные в порядке создания.

## Копирование объектов
> Переменная хранит не сам объект, а его «адрес в памяти», другими словами «ссылку» на него.

> Операторы равенства == и строгого равенства === для объектов работают одинаково.
Два объекта равны только в том случае, если это один и тот же объект.

> Для сравнений типа obj1 > obj2 или для сравнения с примитивом obj == 5 объекты преобразуются в примитивы.

Чтобы сделать реальную копию объекта надо использовать ```Object.assign(dest, [objeects])```
```
Object.assign(dest, [src1, src2, src3...])
```
Метод копирует в ```dest``` все свойства объектов массива. Одинаковые свойства перезаписываются.

> Если одно из значений является объектом - придется рекурсивно перебирать и его. ПРоще использовать ```JSON```.

## Работа с памятью
Все просто - удалется все что является недостижимым. 

## SYMBOL
```SYMBOL``` - уникальный идентификатор.
```
let id = Symbol("id");
```
Символы с одинаковым описанием - не равны
```
let id1 = Symbol("id");
let id2 = Symbol("id");
alert(id1 == id2); // false
```
> Символы нельзя НЕявно преобразовать в строку
```
symbol.description // id
```
> Они нужны для того, чтобы добавлять свойства к объектам задействованным в стороннем коде. Потому что - например, их игнорирует ```for in``` и ```Object.keys(user)```. Таким образом сторонний код не сможет их задеть.

Если мы хотим работать символом из разных частей приложения - есть глобальный реестр символов.
Для чтения (или, при отсутствии, создания) символа из реестра используется вызов ```Symbol.for(key)```

## Системные символы
Существует множество «системных» символов, использующихся внутри самого JavaScript, и мы можем использовать их, чтобы настраивать различные аспекты поведения объектов.
Эти символы перечислены в спецификации в таблице Well-known symbols:
```Symbol.hasInstance```
```Symbol.isConcatSpreadable```
```Symbol.iterator```
```Symbol.toPrimitive```
…и так далее.
В частности, Symbol.toPrimitive позволяет описать правила для объекта, согласно которым он будет преобразовываться к примитиву.







